<?php
/*
 * This file is part of the Eventum (Issue Tracking System) package.
 *
 * @copyright (c) Eventum Team
 * @license GNU General Public License, version 2 or later (GPL-2+)
 *
 * For the full copyright and license information,
 * please see the COPYING and AUTHORS files
 * that were distributed with this source code.
 */

namespace Eventum;

use Crypto;
use RandomLib;

/**
 * Class EncryptedValue
 *
 * @package Eventum
 */
class EncryptedValue
{
    /**
     * Encrypts a message.
     * $plaintext is the message to encrypt.
     * $key is the encryption key, a value generated by CreateNewRandomKey().
     *
     * @param string $plaintext
     * @param string $key optional key to encrypt
     * @return string
     * @throws \CannotPerformOperationException
     */
    public static function encrypt($plaintext, $key = null)
    {
        return rtrim(
            base64_encode(
                Crypto::encrypt($plaintext, $key ?: self::getKey())
            ), '='
        );
    }

    /**
     * Decrypts a ciphertext.
     * $ciphertext is the ciphertext to decrypt.
     *
     * @param string $ciphertext
     * @return string
     * @throws \CannotPerformOperationException
     * @throws \InvalidCiphertextException
     */
    public static function decrypt($ciphertext)
    {
        return Crypto::decrypt(base64_decode($ciphertext), self::getKey());
    }

    /**
     * Key rotation method -- decrypt with your old key then re-encrypt with your new key
     *
     * @param string $key the new key
     * @param string $data
     * @return string
     */
    public static function rotate($key, $data)
    {
        return self::encrypt(self::decrypt($data), $key);
    }

    private static function getKey()
    {
        static $key;
        if (!$key) {
            // use RandomLib to get most compatible implementation
            // Crypto uses mcrypt *ONLY* without any fallback
            $factory = new RandomLib\Factory();
            $generator = $factory->getMediumStrengthGenerator();
            $key = $generator->generate(Crypto::KEY_BYTE_SIZE);
        }
        return $key;
    }
}
