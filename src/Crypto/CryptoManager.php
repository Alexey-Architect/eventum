<?php

/*
 * This file is part of the Eventum (Issue Tracking System) package.
 *
 * @copyright (c) Eventum Team
 * @license GNU General Public License, version 2 or later (GPL-2+)
 *
 * For the full copyright and license information,
 * please see the COPYING and AUTHORS files
 * that were distributed with this source code.
 */

namespace Eventum\Crypto;

use BadMethodCallException;
use Crypto;
use CryptoTestFailedException;
use Email_Account;
use InvalidArgumentException;
use RandomLib;
use Setup;
use Zend\Config\Config;

/**
 * Class Crypto Manager.
 *
 * Provides methods to encrypt/decrypt a text using own private key.
 * The encrypted value is base64 encoded so it's safe to store to database.
 *
 * @package Eventum\Crypto
 */
class CryptoManager
{
    /**
     * @return bool return true if Encryption is enabled
     */
    public static function encryptionEnabled()
    {
        static $enabled;

        if ($enabled == null) {
            $enabled = Setup::get()->encryption == 'enabled';
        }

        return $enabled;
    }

    /**
     * Enable encryption
     *
     * @throws CryptoException if that can not be performed
     */
    public static function enableEncryption()
    {
        CryptoManager::canEncrypt();
        Setup::save(array('encryption' => 'enabled'));
        if (!self::encryptionEnabled()) {
            throw new CryptoException('bug');
        }

        // upgrade config
        $config = Setup::get();
        self::upgradeConfig($config);
        Setup::save();
    }

    /**
     * Disable encryption
     */
    public static function disableEncryption()
    {
        Setup::save(array('encryption' => 'disabled'));
        if (self::encryptionEnabled()) {
            throw new CryptoException('bug');
        }
    }

    /**
     * Checks if system can perform encryption:
     * - has mcrypt extension
     * - some other tests performed by Crypto library
     *
     * @throws CryptoException if it can't be enabled
     * @return bool
     */
    private static function canEncrypt()
    {
        try {
            Crypto::RuntimeTest();
        } catch (CryptoTestFailedException $e) {
            throw new CryptoException($e->getMessage(), $e->getCode(), $e);
        }

        return true;
    }

    /**
     * Encrypts a message.
     * $plaintext is the message to encrypt.
     * $key is the encryption key, a value generated by CreateNewRandomKey().
     *
     * @param string $plaintext
     * @param string $key optional key to encrypt
     * @return string
     * @throws \CannotPerformOperationException
     */
    public static function encrypt($plaintext, $key = null)
    {
        if ($plaintext === null || $plaintext === false) {
            throw new InvalidArgumentException('Refusing to encrypt empty value');
        }

        if (!self::encryptionEnabled()) {
            return $plaintext;
        }

        return rtrim(
            base64_encode(
                Crypto::encrypt($plaintext, $key ?: self::getKey())
            ), '='
        );
    }

    /**
     * Decrypts a ciphertext.
     * $ciphertext is the ciphertext to decrypt.
     *
     * @param string $ciphertext
     * @return string
     * @throws \CannotPerformOperationException
     * @throws \InvalidCiphertextException
     */
    public static function decrypt($ciphertext)
    {
        if (!self::encryptionEnabled()) {
            return $ciphertext;
        }

        return Crypto::decrypt(
            base64_decode($ciphertext),
            self::getKey()
        );
    }

    /**
     * Key rotation method -- decrypt with your old key then re-encrypt with your new key
     *
     * @param string $ciphertext
     * @param string $key the new key
     * @return string
     */
    public static function rotate($ciphertext, $key)
    {
        if (!self::encryptionEnabled()) {
            return $ciphertext;
        }

        return self::encrypt(self::decrypt($ciphertext), $key);
    }

    /**
     * Generate new encryption key and re-encrypt data
     */
    public static function regenerateKey()
    {
        throw new CryptoException('Not yet');
    }

    /**
     * Upgrade config so that values contain EncryptedValue where some secrecy is wanted
     *
     * @param Config $config
     */
    public static function upgradeConfig(Config $config)
    {
        if (!$config['database']['password'] instanceof EncryptedValue) {
            $config['database']['password'] = new EncryptedValue(self::encrypt($config['database']['password']));
        }

        if (count($config['ldap']) && !$config['ldap']['bindpw'] instanceof EncryptedValue) {
            $config['ldap']['bindpw'] = new EncryptedValue(self::encrypt($config['ldap']['bindpw']));
        }
    }

    public static function upgradeEmailAccounts()
    {
        // encrypt email account passwords
        $accounts = Email_Account::getList();
        foreach ($accounts as $account) {
            $account = Email_Account::getDetails($account['ema_id']);
            /** @var EncryptedValue $password */
            $password = $account['ema_password'];
            // the raw value contains the original plaintext
            Email_Account::updatePassword($account['ema_id'], $password->getEncrypted());
        }
    }

    /**
     * Load or generate secret key used for crypt
     *
     * @return string
     */
    private static function getKey()
    {
        static $key;
        if (!$key) {
            $secret_file = APP_CONFIG_PATH . '/secret_key.php';
            $key = self::loadPrivateKey($secret_file);

            if (!$key) {
                // use RandomLib to get most compatible implementation
                // Crypto uses mcrypt *ONLY* without any fallback
                $factory = new RandomLib\Factory();
                $generator = $factory->getMediumStrengthGenerator();
                $key = $generator->generate(Crypto::KEY_BYTE_SIZE);

                self::storePrivateKey($secret_file, $key);
            }
        }

        return $key;
    }

    private static function loadPrivateKey($file)
    {
        if (!file_exists($file)) {
            return null;
        }
        if (!is_readable($file)) {
            throw new InvalidArgumentException("Secret file '$file' not readable");
        }
        $private_key = trim(file_get_contents($file));
        if (!$private_key) {
            throw new InvalidArgumentException("Unable to read secret file '$file");
        }

        return $private_key;
    }

    private static function storePrivateKey($file, $key)
    {
        if (file_exists($file) && !is_writable($file)) {
            throw new InvalidArgumentException("Secret file '$file' not writable");
        }
        $res = file_put_contents($file, $key);
        if (!$res) {
            throw new BadMethodCallException("Unable to store secret file '$file'");
        }
    }
}
